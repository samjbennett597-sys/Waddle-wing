<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Waddle Wings: Flappy Penguin</title>

    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2C3E50">

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #333;
            overflow: hidden;
            font-family: 'Fredoka One', cursive;
            touch-action: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            overscroll-behavior: none;
        }

        #game-container {
            position: relative;
            max-width: 100%;
            max-height: 100%;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        canvas {
            display: block;
            background: linear-gradient(to bottom, #87CEEB, #E0F7FA);
        }

        #ui-layer {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        #top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.4);
            font-size: 1.1rem;
        }

        #score-display {
            font-size: 2.4rem;
        }

        #lives-display {
            font-size: 1.3rem;
        }

        .center-card {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(255, 255, 255, 0.95);
            padding: 26px;
            border-radius: 20px;
            border: 4px solid #2C3E50;
            box-shadow: 0 10px 25px rgba(0,0,0,0.25);
            min-width: 260px;
            pointer-events: auto;
        }

        h1 {
            color: #2C3E50;
            margin: 0 0 10px 0;
            font-size: 1.9rem;
        }

        p {
            color: #555;
            font-size: 1rem;
            margin: 8px 0 14px;
        }

        button {
            background: #FF6B6B;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1.1rem;
            border-radius: 40px;
            cursor: pointer;
            font-family: 'Fredoka One', cursive;
            transition: transform 0.1s, background 0.2s;
            box-shadow: 0 4px 0 #C44D4D;
            margin: 6px 4px;
        }

        button:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #C44D4D;
        }

        button:hover {
            background: #FF5252;
        }

        .small {
            padding: 8px 18px;
            font-size: 0.9rem;
        }

        .hidden {
            display: none !important;
        }

        #fake-ad-progress {
            width: 100%;
            height: 10px;
            border-radius: 999px;
            background: #eee;
            overflow: hidden;
            margin-top: 10px;
        }

        #fake-ad-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg,#FF6B6B,#FFD66B);
        }

        #fake-ad-timer {
            font-size: 0.9rem;
            color: #555;
            margin-top: 6px;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="top-bar">
            <div id="score-display">0</div>
            <div id="lives-display">♥ 5</div>
        </div>
    </div>

    <!-- Start screen -->
    <div id="start-screen" class="center-card">
        <h1>WADDLE WINGS</h1>
        <p>Tap, click or press Space to flap.<br>Lose a life each time you crash.</p>
        <button id="start-btn">PLAY</button>
    </div>

    <!-- Game over screen -->
    <div id="game-over-screen" class="center-card hidden">
        <h1>OOF!</h1>
        <p>Score: <span id="final-score">0</span></p>
        <p>Best: <span id="best-score">0</span></p>
        <p>Lives left: <span id="lives-left-label">0</span></p>
        <button id="restart-btn">TRY AGAIN</button>
        <button id="back-menu-btn" class="small">BACK TO MENU</button>
    </div>

    <!-- Out of lives screen -->
    <div id="no-lives-screen" class="center-card hidden">
        <h1>NO LIVES</h1>
        <p>You’ve used all your lives.</p>
        <p style="font-size:0.9rem;">Lives slowly refill over time (1 per hour).<br>
        Or watch a short “ad” to get +1 life instantly.</p>
        <button id="watch-ad-btn">WATCH AD</button>
        <button id="back-from-nolives-btn" class="small">BACK TO MENU</button>
    </div>

    <!-- Fake ad screen -->
    <div id="fake-ad-screen" class="center-card hidden">
        <h1>Ad playing…</h1>
        <p style="font-size:0.9rem;">Pretend this is some dodgy mobile game trailer.</p>
        <div id="fake-ad-progress">
            <div id="fake-ad-bar"></div>
        </div>
        <div id="fake-ad-timer">5s remaining</div>
    </div>
</div>

<script>
    /* ========= CANVAS & BASIC SETUP ========= */
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
        const maxWidth = 480;
        const maxHeight = 800;

        let width = window.innerWidth;
        let height = window.innerHeight;

        if (width > maxWidth) {
            width = maxWidth;
            height = Math.min(window.innerHeight, maxHeight);
        }

        canvas.width = width;
        canvas.height = height;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    /* ========= DOM HOOKS ========= */
    const scoreEl = document.getElementById('score-display');
    const livesEl = document.getElementById('lives-display');

    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const noLivesScreen = document.getElementById('no-lives-screen');
    const fakeAdScreen = document.getElementById('fake-ad-screen');

    const startBtn = document.getElementById('start-btn');
    const restartBtn = document.getElementById('restart-btn');
    const backMenuBtn = document.getElementById('back-menu-btn');
    const watchAdBtn = document.getElementById('watch-ad-btn');
    const backFromNoLivesBtn = document.getElementById('back-from-nolives-btn');

    const finalScoreEl = document.getElementById('final-score');
    const bestScoreEl = document.getElementById('best-score');
    const livesLeftLabel = document.getElementById('lives-left-label');

    const fakeAdBar = document.getElementById('fake-ad-bar');
    const fakeAdTimer = document.getElementById('fake-ad-timer');

    /* ========= GAME CONSTANTS ========= */
    const GRAVITY = 0.25;
    const FLAP_STRENGTH = -5.5;
    const PIPE_SPEED = 3;
    const PIPE_SPAWN_RATE = 100;
    const PIPE_GAP = 160;

    // Lives system (Option B)
    const MAX_LIVES = 5;
    const REGEN_TIME = 60 * 60 * 1000; // 1 hour per life

    // Lives in storage – safe init
    let livesStored = localStorage.getItem('ww_lives');
    let lives;
    if (livesStored === null) {
        lives = MAX_LIVES;
        localStorage.setItem('ww_lives', String(MAX_LIVES));
    } else {
        lives = parseInt(livesStored, 10);
        if (Number.isNaN(lives) || lives < 0 || lives > MAX_LIVES) {
            lives = MAX_LIVES;
            localStorage.setItem('ww_lives', String(MAX_LIVES));
        }
    }

    let lastLifeTimestampStored = localStorage.getItem('ww_lastLife');
    let lastLifeTimestamp;
    if (lastLifeTimestampStored === null) {
        lastLifeTimestamp = Date.now();
        localStorage.setItem('ww_lastLife', String(lastLifeTimestamp));
    } else {
        lastLifeTimestamp = parseInt(lastLifeTimestampStored, 10);
        if (Number.isNaN(lastLifeTimestamp)) {
            lastLifeTimestamp = Date.now();
            localStorage.setItem('ww_lastLife', String(lastLifeTimestamp));
        }
    }

    function updateLivesUI() {
        livesEl.textContent = '♥ ' + lives;
    }

    function regenLives() {
        const now = Date.now();
        if (lives >= MAX_LIVES) {
            lastLifeTimestamp = now;
            localStorage.setItem('ww_lastLife', String(lastLifeTimestamp));
            return;
        }

        const elapsed = now - lastLifeTimestamp;
        const regained = Math.floor(elapsed / REGEN_TIME);

        if (regained > 0) {
            lives = Math.min(MAX_LIVES, lives + regained);
            lastLifeTimestamp = now;
            localStorage.setItem('ww_lives', String(lives));
            localStorage.setItem('ww_lastLife', String(lastLifeTimestamp));
            updateLivesUI();
        }
    }

    // Run once on load and every 30s
    regenLives();
    updateLivesUI();
    setInterval(regenLives, 30 * 1000);

    /* ========= SNOW BACKGROUND ========= */
    const snowflakes = [];
    function initSnow() {
        snowflakes.length = 0;
        for (let i = 0; i < 50; i++) {
            snowflakes.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                r: Math.random() * 2 + 1,
                speed: Math.random() * 1 + 0.5
            });
        }
    }
    initSnow();

    function drawBackground() {
        const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, '#87CEEB');
        grad.addColorStop(1, '#E0F7FA');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        snowflakes.forEach(flake => {
            ctx.beginPath();
            ctx.arc(flake.x, flake.y, flake.r, 0, Math.PI * 2);
            ctx.fill();

            flake.y += flake.speed;
            flake.x += Math.sin((flake.y + performance.now() * 0.002)) * 0.2;

            if (flake.y > canvas.height) {
                flake.y = -5;
                flake.x = Math.random() * canvas.width;
            }
        });
    }

    /* ========= GAME STATE ========= */
    let frames = 0;
    let score = 0;
    let highScore = parseInt(localStorage.getItem('waddleHighScore') || '0', 10);
    let isRunning = false;
    let isGameOver = false;

    /* ========= PENGUIN ========= */
    const penguin = {
        x: 0,
        y: 0,
        radius: 18,
        velocity: 0,
        rotation: 0,

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);

            const rot = this.velocity * 0.1;
            this.rotation = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, rot));
            ctx.rotate(this.rotation);

            ctx.fillStyle = '#2C3E50';
            ctx.beginPath();
            ctx.ellipse(0, 0, 20, 25, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.ellipse(-2, 2, 14, 18, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(6, -8, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(8, -8, 2, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#FF9800';
            ctx.beginPath();
            ctx.moveTo(10, -2);
            ctx.lineTo(24, 2);
            ctx.lineTo(10, 6);
            ctx.fill();

            ctx.fillStyle = '#34495E';
            ctx.beginPath();
            const wingY = Math.sin(frames * 0.25) * 3;
            ctx.ellipse(-5, 5 + wingY, 8, 14, -0.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#FF9800';
            ctx.beginPath();
            ctx.ellipse(-5, 22, 6, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        },

        update() {
            this.velocity += GRAVITY;
            this.y += this.velocity;

            if (this.y + this.radius >= canvas.height) {
                this.y = canvas.height - this.radius;
                triggerGameOver();
            }

            if (this.y - this.radius <= 0) {
                this.y = this.radius;
                this.velocity = 0;
            }
        },

        flap() {
            this.velocity = FLAP_STRENGTH;
        },

        reset() {
            this.x = canvas.width * 0.2;
            this.y = canvas.height / 2;
            this.velocity = 0;
            this.rotation = 0;
        }
    };

    /* ========= PIPES ========= */
    const pipes = {
        items: [],

        reset() {
            this.items = [];
        },

        update() {
            if (frames % PIPE_SPAWN_RATE === 0) {
                const minPipeLen = 50;
                const maxPos = canvas.height - minPipeLen - PIPE_GAP;
                const minPos = minPipeLen;
                const topY = Math.floor(Math.random() * (maxPos - minPos + 1)) + minPos;

                this.items.push({
                    x: canvas.width,
                    y: topY,
                    passed: false
                });
            }

            for (let i = 0; i < this.items.length; i++) {
                const p = this.items[i];
                p.x -= PIPE_SPEED;

                const pipeWidth = 60;
                const pLeft = penguin.x - penguin.radius;
                const pRight = penguin.x + penguin.radius;
                const pTop = penguin.y - penguin.radius;
                const pBottom = penguin.y + penguin.radius;

                if (pRight > p.x && pLeft < p.x + pipeWidth) {
                    if (pTop < p.y || pBottom > p.y + PIPE_GAP) {
                        triggerGameOver();
                    }
                }

                if (p.x + pipeWidth < penguin.x && !p.passed) {
                    p.passed = true;
                    score++;
                    scoreEl.textContent = score;
                }

                if (p.x + pipeWidth < 0) {
                    this.items.shift();
                    i--;
                }
            }
        },

        draw() {
            for (let i = 0; i < this.items.length; i++) {
                const p = this.items[i];
                const pipeWidth = 60;

                const gradTop = ctx.createLinearGradient(p.x, 0, p.x + pipeWidth, 0);
                gradTop.addColorStop(0, '#A5F2F3');
                gradTop.addColorStop(0.5, '#E0FFFF');
                gradTop.addColorStop(1, '#A5F2F3');

                ctx.fillStyle = gradTop;
                ctx.fillRect(p.x, 0, pipeWidth, p.y);

                ctx.fillStyle = '#E0FFFF';
                ctx.beginPath();
                ctx.moveTo(p.x + 10, p.y);
                ctx.lineTo(p.x + 30, p.y + 20);
                ctx.lineTo(p.x + 50, p.y);
                ctx.fill();

                const gradBot = ctx.createLinearGradient(p.x, 0, p.x + pipeWidth, 0);
                gradBot.addColorStop(0, '#A5F2F3');
                gradBot.addColorStop(0.5, '#E0FFFF');
                gradBot.addColorStop(1, '#A5F2F3');

                ctx.fillStyle = gradBot;
                ctx.fillRect(
                    p.x,
                    p.y + PIPE_GAP,
                    pipeWidth,
                    canvas.height - (p.y + PIPE_GAP)
                );

                ctx.fillStyle = '#E0FFFF';
                ctx.beginPath();
                ctx.moveTo(p.x + 10, p.y + PIPE_GAP);
                ctx.lineTo(p.x + 30, p.y + PIPE_GAP - 20);
                ctx.lineTo(p.x + 50, p.y + PIPE_GAP);
                ctx.fill();

                ctx.strokeStyle = '#5DBCD2';
                ctx.lineWidth = 2;
                ctx.strokeRect(p.x, -2, pipeWidth, p.y + 2);
                ctx.strokeRect(p.x, p.y + PIPE_GAP, pipeWidth, canvas.height);
            }
        }
    };

    /* ========= MAIN LOOP ========= */
    function loop() {
        if (!isRunning) return;

        penguin.update();
        pipes.update();
        frames++;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBackground();
        pipes.draw();
        penguin.draw();

        if (!isGameOver) {
            requestAnimationFrame(loop);
        }
    }

    /* ========= GAME FLOW ========= */

    function resetScreens() {
        startScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');
        noLivesScreen.classList.add('hidden');
        fakeAdScreen.classList.add('hidden');
    }

    function tryStartGame() {
        regenLives();      // top up if enough time passed
        updateLivesUI();

        if (lives <= 0) {
            // No lives – show the no-lives popup instead
            resetScreens();
            noLivesScreen.classList.remove('hidden');
            isRunning = false;
            isGameOver = false;
            return;
        }

        resetScreens();

        score = 0;
        frames = 0;
        scoreEl.textContent = score;

        penguin.reset();
        pipes.reset();
        initSnow();

        isGameOver = false;
        isRunning = true;
        loop();
    }

    function triggerGameOver() {
        if (isGameOver) return;
        isGameOver = true;
        isRunning = false;

        // Lose one life on death (Option B)
        lives = Math.max(0, lives - 1);
        localStorage.setItem('ww_lives', String(lives));
        lastLifeTimestamp = Date.now();
        localStorage.setItem('ww_lastLife', String(lastLifeTimestamp));
        updateLivesUI();

        finalScoreEl.textContent = score;
        if (score > highScore) {
            highScore = score;
            localStorage.setItem('waddleHighScore', String(highScore));
        }
        bestScoreEl.textContent = highScore;
        livesLeftLabel.textContent = lives;

        // Show game-over screen
        resetScreens();
        gameOverScreen.classList.remove('hidden');
    }

    /* ========= INPUT ========= */

    function handleFlapInput(e) {
        if (e && e.type === 'keydown' && e.code === 'Space') {
            e.preventDefault();
        }
        if (!isRunning || isGameOver) return;
        penguin.flap();
    }

    window.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
            if (!isRunning && !isGameOver && !startScreen.classList.contains('hidden')) {
                tryStartGame();
            } else if (!isRunning && isGameOver && !gameOverScreen.classList.contains('hidden')) {
                if (lives > 0) {
                    tryStartGame();
                } else {
                    resetScreens();
                    noLivesScreen.classList.remove('hidden');
                }
            } else {
                handleFlapInput(e);
            }
        }
    });

    canvas.addEventListener('mousedown', handleFlapInput);
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (!isRunning && !isGameOver && !startScreen.classList.contains('hidden')) {
            tryStartGame();
        } else if (!isRunning && isGameOver && !gameOverScreen.classList.contains('hidden')) {
            if (lives > 0) {
                tryStartGame();
            } else {
                resetScreens();
                noLivesScreen.classList.remove('hidden');
            }
        } else {
            handleFlapInput(e);
        }
    }, { passive: false });

    /* ========= BUTTON HANDLERS ========= */
    startBtn.addEventListener('click', tryStartGame);

    restartBtn.addEventListener('click', () => {
        if (lives > 0) {
            tryStartGame();
        } else {
            resetScreens();
            noLivesScreen.classList.remove('hidden');
        }
    });

    backMenuBtn.addEventListener('click', () => {
        resetScreens();
        startScreen.classList.remove('hidden');
    });

    backFromNoLivesBtn.addEventListener('click', () => {
        resetScreens();
        startScreen.classList.remove('hidden');
    });

    watchAdBtn.addEventListener('click', () => {
        // Start fake ad
        resetScreens();
        fakeAdScreen.classList.remove('hidden');
        runFakeAd();
    });

    /* ========= FAKE REWARDED AD ========= */
    function runFakeAd() {
        let duration = 5; // seconds
        let remaining = duration;
        fakeAdBar.style.width = '0%';
        fakeAdTimer.textContent = `${remaining}s remaining`;

        const interval = setInterval(() => {
            remaining--;
            const pct = ((duration - remaining) / duration) * 100;
            fakeAdBar.style.width = pct + '%';
            fakeAdTimer.textContent = `${Math.max(remaining, 0)}s remaining`;

            if (remaining <= 0) {
                clearInterval(interval);

                // Simulate "ad finished"
                setTimeout(() => {
                    // Give +1 life
                    lives = Math.min(MAX_LIVES, lives + 1);
                    localStorage.setItem('ww_lives', String(lives));
                    lastLifeTimestamp = Date.now();
                    localStorage.setItem('ww_lastLife', String(lastLifeTimestamp));
                    updateLivesUI();

                    // Back to menu
                    resetScreens();
                    startScreen.classList.remove('hidden');
                    alert('Thanks for watching! You gained +1 life.');
                }, 300);
            }
        }, 1000);
    }

    /* ========= INITIAL DRAW ========= */
    penguin.reset();
    drawBackground();
    penguin.draw();
    updateLivesUI();

    // Service worker
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker
                .register('./sw.js')
                .catch(() => {});
        });
    }
</script>
</body>
</html>
