<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Waddle Wings: Flappy Penguin</title>

    <!-- This minimal PWA setup is included but is functional only if manifest.json and sw.js are present. -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2C3E50">

    <style>
        /* Import a fun, readable font */
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #333;
            overflow: hidden;
            font-family: 'Fredoka One', cursive;
            touch-action: none; /* Prevent zoom/scroll on mobile */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            overscroll-behavior: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            max-width: 100%;
            max-height: 100%;
        }

        canvas {
            display: block;
            /* Background gradient for the sky/ice cave */
            background: linear-gradient(to bottom, #87CEEB, #E0F7FA);
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #score-display {
            text-align: center;
            font-size: 4rem;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.4);
            margin-top: 20px;
            pointer-events: none;
        }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(255, 255, 255, 0.9);
            padding: 30px;
            border-radius: 20px;
            border: 4px solid #2C3E50;
            pointer-events: auto;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            min-width: 250px;
        }

        h1 {
            color: #2C3E50;
            margin: 0 0 10px 0;
            font-size: 2rem;
        }

        p {
            color: #555;
            font-size: 1.2rem;
            margin: 10px 0 20px 0;
        }

        button {
            background: #FF6B6B; /* Red/Orange theme */
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.5rem;
            border-radius: 50px;
            cursor: pointer;
            font-family: 'Fredoka One', cursive;
            transition: transform 0.1s, background 0.2s;
            box-shadow: 0 4px 0 #C44D4D; /* 3D effect */
        }

        button:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #C44D4D;
        }

        button:hover {
            background: #FF5252;
        }

        .hidden {
            display: none !important;
        }

    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>

        <div id="ui-layer">
            <div id="score-display">0</div>
        </div>

        <div id="start-screen">
            <h1>WADDLE WINGS</h1>
            <p>Tap, Click, or Spacebar to Fly!</p>
            <button id="start-btn">PLAY</button>
        </div>

        <div id="game-over-screen" class="hidden">
            <h1>OOF!</h1>
            <p>Score: <span id="final-score">0</span></p>
            <p>Best: <span id="best-score">0</span></p>
            <button id="restart-btn">TRY AGAIN</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score-display');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreEl = document.getElementById('final-score');
        const bestScoreEl = document.getElementById('best-score');
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');

        // Responsive Canvas Sizing
        function resizeCanvas() {
            // Limit width for desktop playability, full width for mobile
            const maxWidth = 480; 
            const maxHeight = 800;

            let width = window.innerWidth;
            let height = window.innerHeight;

            if (width > maxWidth) {
                width = maxWidth;
                height = Math.min(window.innerHeight, maxHeight);
            }

            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Game Constants
        const GRAVITY = 0.25;
        const FLAP_STRENGTH = -5.5;
        const PIPE_SPEED = 3;
        const PIPE_SPAWN_RATE = 100; // Frames
        const PIPE_GAP = 160;

        // Assets (Snowflakes for background detail)
        const snowflakes = [];
        for(let i=0; i<50; i++) {
            snowflakes.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                r: Math.random() * 2 + 1,
                speed: Math.random() * 1 + 0.5
            });
        }

        // Game State
        let frames = 0;
        let score = 0;
        // Use localStorage for simple high score tracking
        let highScore = localStorage.getItem('waddleHighScore') || 0; 
        let isRunning = false;
        let isGameOver = false;

        // Penguin Object
        const penguin = {
            x: 0,
            y: 0,
            radius: 18,
            velocity: 0,
            rotation: 0,

            draw: function() {
                ctx.save();
                ctx.translate(this.x, this.y);
                // Rotate based on velocity (waddle/dive effect)
                let rot = this.velocity * 0.1;
                this.rotation = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, rot));
                ctx.rotate(this.rotation);

                // Draw Penguin (Stylized for simplicity)

                // Body (Dark Blue/Black)
                ctx.fillStyle = '#2C3E50'; 
                ctx.beginPath();
                ctx.ellipse(0, 0, 20, 25, 0, 0, Math.PI * 2);
                ctx.fill();

                // Belly (White)
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.ellipse(-2, 2, 14, 18, 0, 0, Math.PI * 2);
                ctx.fill();

                // Eyes
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(6, -8, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(8, -8, 2, 0, Math.PI * 2);
                ctx.fill();

                // Beak (Orange)
                ctx.fillStyle = '#FF9800';
                ctx.beginPath();
                ctx.moveTo(10, -2);
                ctx.lineTo(24, 2);
                ctx.lineTo(10, 6);
                ctx.fill();

                // Wing (Flapping animation)
                ctx.fillStyle = '#34495E';
                ctx.beginPath();
                let wingY = Math.sin(frames * 0.2) * 3;
                ctx.ellipse(-5, 5 + wingY, 8, 14, -0.5, 0, Math.PI * 2);
                ctx.fill();

                // Feet (Orange)
                ctx.fillStyle = '#FF9800';
                ctx.beginPath();
                ctx.ellipse(-5, 22, 6, 4, 0, 0, Math.PI*2);
                ctx.fill();

                ctx.restore();
            },

            update: function() {
                this.velocity += GRAVITY;
                this.y += this.velocity;

                // Floor collision (game over)
                if (this.y + this.radius >= canvas.height) {
                    this.y = canvas.height - this.radius;
                    gameOver();
                }

                // Ceiling collision
                if (this.y - this.radius <= 0) {
                    this.y = this.radius;
                    this.velocity = 0;
                }
            },

            flap: function() {
                this.velocity = FLAP_STRENGTH;
            },

            reset: function() {
                this.x = canvas.width * 0.2; 
                this.y = canvas.height / 2;
                this.velocity = 0;
                this.rotation = 0;
            }
        };

        // Pipe/Obstacle Object
        const pipes = {
            items: [],

            reset: function() {
                this.items = [];
            },

            update: function() {
                // Pipe Spawning
                if (frames % PIPE_SPAWN_RATE === 0) {
                    // Logic to determine a random vertical gap position
                    const minPipeLen = 50;
                    const maxPos = canvas.height - minPipeLen - PIPE_GAP;
                    const minPos = minPipeLen;
                    const topY = Math.floor(Math.random() * (maxPos - minPos + 1)) + minPos;

                    this.items.push({
                        x: canvas.width,
                        y: topY, // Bottom edge of the top pipe
                        passed: false
                    });
                }

                // Pipe Movement and Collision Check
                for (let i = 0; i < this.items.length; i++) {
                    let p = this.items[i];
                    p.x -= PIPE_SPEED;

                    // --- Collision Detection (Simplified AABB) ---
                    const pipeWidth = 60;
                    const pLeft = penguin.x - penguin.radius;
                    const pRight = penguin.x + penguin.radius;
                    const pTop = penguin.y - penguin.radius;
                    const pBottom = penguin.y + penguin.radius;

                    // Check if penguin is horizontally aligned with the pipe
                    if (pRight > p.x && pLeft < p.x + pipeWidth) {
                        // Top Pipe Collision
                        if (pTop < p.y) {
                            gameOver();
                        }
                        // Bottom Pipe Collision
                        if (pBottom > p.y + PIPE_GAP) {
                            gameOver();
                        }
                    }

                    // Score Update (Passed the pipe's horizontal position)
                    if (p.x + pipeWidth < penguin.x && !p.passed) {
                        score++;
                        scoreEl.innerText = score;
                        p.passed = true;
                    }

                    // Remove off-screen pipes
                    if (p.x + pipeWidth < 0) {
                        this.items.shift();
                        i--;
                    }
                }
            },

            draw: function() {
                for (let i = 0; i < this.items.length; i++) {
                    let p = this.items[i];
                    let pipeWidth = 60;

                    // Top Pipe Drawing (Ice style)
                    let gradTop = ctx.createLinearGradient(p.x, 0, p.x + pipeWidth, 0);
                    gradTop.addColorStop(0, '#A5F2F3');
                    gradTop.addColorStop(0.5, '#E0FFFF');
                    gradTop.addColorStop(1, '#A5F2F3');

                    ctx.fillStyle = gradTop;
                    ctx.fillRect(p.x, 0, pipeWidth, p.y);

                    // Ice detail on cap
                    ctx.fillStyle = '#E0FFFF';
                    ctx.beginPath();
                    ctx.moveTo(p.x + 10, p.y);
                    ctx.lineTo(p.x + 30, p.y + 20);
                    ctx.lineTo(p.x + 50, p.y);
                    ctx.fill();

                    // Bottom Pipe Drawing
                    let gradBot = ctx.createLinearGradient(p.x, 0, p.x + pipeWidth, 0);
                    gradBot.addColorStop(0, '#A5F2F3');
                    gradBot.addColorStop(0.5, '#E0FFFF');
                    gradBot.addColorStop(1, '#A5F2F3');

                    ctx.fillStyle = gradBot;
                    ctx.fillRect(p.x, p.y + PIPE_GAP, pipeWidth, canvas.height - (p.y + PIPE_GAP));

                    // Ice detail on base
                    ctx.fillStyle = '#E0FFFF';
                    ctx.beginPath();
                    ctx.moveTo(p.x + 10, p.y + PIPE_GAP);
                    ctx.lineTo(p.x + 30, p.y + PIPE_GAP - 20);
                    ctx.lineTo(p.x + 50, p.y + PIPE_GAP);
                    ctx.fill();

                    // Borders for definition
                    ctx.strokeStyle = '#5DBCD2';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(p.x, -2, pipeWidth, p.y + 2); 
                    ctx.strokeRect(p.x, p.y + PIPE_GAP, pipeWidth, canvas.height);
                }
            }
        };

        function drawBackground() {
            // Draw Snowflakes (subtle background animation)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            snowflakes.forEach(flake => {
                ctx.beginPath();
                ctx.arc(flake.x, flake.y, flake.r, 0, Math.PI * 2);
                ctx.fill();

                flake.y += flake.speed;
                flake.x += Math.sin(frames * 0.01 + flake.y) * 0.5; 

                // Reset snowflake when it goes off screen
                if (flake.y > canvas.height) {
                    flake.y = -5;
                    flake.x = Math.random() * canvas.width;
                }
            });
        }

        // Main Game Loop
        function loop() {
            if (!isRunning) return;

            // Update
            penguin.update();
            pipes.update();
            frames++;

            // Draw
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();
            pipes.draw();
            penguin.draw(); 

            if (!isGameOver) {
                requestAnimationFrame(loop);
            }
        }

        // State Management
        function startGame() {
            penguin.reset();
            pipes.reset();
            score = 0;
            frames = 0;
            scoreEl.innerText = score;
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            isRunning = true;
            isGameOver = false;
            resizeCanvas(); 
            loop();
        }

        function gameOver() {
            isRunning = false;
            isGameOver = true;
            finalScoreEl.innerText = score;
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('waddleHighScore', highScore);
            }
            bestScoreEl.innerText = highScore;
            gameOverScreen.classList.remove('hidden');
        }

        // Input Handling
        function handleInput(e) {
            if (e.type === 'keydown' && e.code === 'Space') {
                e.preventDefault();
            }

            if (isGameOver) return;

            if (isRunning) {
                penguin.flap();
            }
        }

        // Event Listeners
        startBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('click', startGame);

        // Keyboard Input (Spacebar)
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                if (!isRunning && !startScreen.classList.contains('hidden') || !isRunning && !gameOverScreen.classList.contains('hidden')) {
                    startGame();
                } else {
                    handleInput(e);
                }
            }
        });

        // Touch/Click Input (Handles mobile tap and desktop click)
        canvas.addEventListener('mousedown', handleInput);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); 
             if (!isRunning && !startScreen.classList.contains('hidden') || !isRunning && !gameOverScreen.classList.contains('hidden')) {
                startGame();
            } else {
                handleInput(e);
            }
        }, {passive: false});

        // PWA Service Worker Registration (If you use sw.js and manifest.json)
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // This assumes a separate sw.js file exists in the same directory.
                navigator.serviceWorker.register('./sw.js') 
                    .then(reg => console.log('Service Worker registered'))
                    .catch(err => console.log('SW Registration failed', err));
            });
        }

        // Initial draw when the page loads
        penguin.reset();
        drawBackground();
        penguin.draw();

    </script>
</body>
</html>
